(globalThis.webpackChunklightning_tunnel=globalThis.webpackChunklightning_tunnel||[]).push([[898],{60980:(e,t,s)=>{"use strict";s.d(t,{Z:()=>l});var r=s(15190);const a={spltAddress:"TokenkegQfeZyiNwAJbNbGKPFXCWuBvf9Ss623VQ5DA",splataAddress:"ATokenGPvbdGVxr1b2hvZbsiqW5xWH25efTNsLJA8knL"},n={devnet:{...a,node:"https://api.devnet.solana.com",sntrAddress:"5YwUkPdXLoujGkZuo9B4LsLKj3hdkDcfP4derpspifSJ",sntrPoolAddress:"3EUPL7YQLbU6DNU5LZeQeHPXTf1MigJ2yASXA9rH5Ku4",swapAddress:"4erFSLP7oBFSVC1t35jdxmbfxEhYCKfoM6XdG2BLR3UF",taxmanAddress:"8UaZw2jDhJzv5V53569JbCd3bD4BnyCfBH3sjwgajGS9"},testnet:{...a,node:"https://api.testnet.solana.com",sntrAddress:"",sntrPoolAddress:"",swapAddress:"",taxmanAddress:""},mainnet:{...a,node:"https://sentre.genesysgo.net",sntrAddress:"SENBBKVCM7homnf5RX9zqpf1GFe935hnbU4uVzY1Y6M",sntrPoolAddress:"Aa3WZX7Xunfebp2MuAcz9CNw8TYTDL7mVrmb11rjyVm6",swapAddress:"SSW7ooZ1EbEognq5GosbygA3uWW1Hq1NsFq6TsftCFV",taxmanAddress:"9doo2HZQEmh2NgfT3Yx12M89aoBheycYqH1eaR5gKb3e"}};const i="lightning_tunnel",o={[i]:{url:"https://github.com/DescartesNetwork/sen-lightning-tunnel/index.js",appId:i,name:"Lightning Tunnel",author:{name:"Sentre",email:"hi@sentre.io"},tags:"solana,dapps,utility".split(",").map((e=>e.trim())),description:"A sample project for Sentre developers",verified:!1}},c={development:{defaultAppId:i,extra:o,senreg:"https://descartesnetwork.github.io/senreg/register.json"},staging:{defaultAppId:i,extra:o,senreg:"https://descartesnetwork.github.io/senreg/register.json"},production:{defaultAppId:i,extra:{},senreg:"https://descartesnetwork.github.io/senreg/register.json"}},d={devnet:{baseURL:"https://stat-dev.sentre.io"},testnet:{baseURL:"https://stat-dev.sentre.io"},mainnet:{baseURL:"https://stat.sentre.io"}},l={sol:n[r.ef],register:c[r.OB],stat:d[r.ef]}},65090:(e,t,s)=>{"use strict";s.d(t,{E5:()=>c,T8:()=>i,ZP:()=>l});var r=s(19289),a=s(95418);const n="accounts",i=(0,r.createAsyncThunk)(`${n}/getAccounts`,(async e=>{let{owner:t}=e;if(!a.account.isAddress(t))throw new Error("Invalid owner/wallet address");const{splt:s}=window.sentre,r=a.account.fromAddress(t),{value:n}=await s.connection.getTokenAccountsByOwner(r,{programId:s.spltProgramId});let i={};return n.forEach((e=>{let{pubkey:t,account:{data:r}}=e;const a=t.toBase58(),n=s.parseAccountData(r);return i[a]=n})),i})),o=(0,r.createAsyncThunk)(`${n}/getAccount`,(async(e,t)=>{let{address:s}=e,{getState:r}=t;if(!a.account.isAddress(s))throw new Error("Invalid account address");const{accounts:{[s]:n}}=r();if(n)return{[s]:n};const{splt:i}=window.sentre;return{[s]:await i.getAccountData(s)}})),c=(0,r.createAsyncThunk)(`${n}/upsetAccount`,(async e=>{let{address:t,data:s}=e;if(!a.account.isAddress(t))throw new Error("Invalid address");if(!s)throw new Error("Data is empty");return{[t]:s}})),d=(0,r.createAsyncThunk)(`${n}/deleteAccount`,(async e=>{let{address:t}=e;if(!a.account.isAddress(t))throw new Error("Invalid address");return{address:t}})),l=(0,r.createSlice)({name:n,initialState:{},reducers:{},extraReducers:e=>{e.addCase(i.fulfilled,((e,t)=>{let{payload:s}=t;return s})).addCase(o.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(c.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(d.fulfilled,((e,t)=>{let{payload:s}=t;delete e[s.address]}))}}).reducer},5105:(e,t,s)=>{"use strict";s.d(t,{Xt:()=>d,Z9:()=>c,ZP:()=>l,fL:()=>o});var r=s(19289),a=s(95418),n=s(3007);const i="flags",o=(0,r.createAsyncThunk)("flags/loadVisited",(async(e,t)=>{let{getState:s}=t;const{wallet:{address:r}}=s();if(!a.account.isAddress(r))throw new Error("Wallet is not connected yet");const i=new n.Z(r).createInstance("sentre");return{visited:await i.getItem("visited")||!1}})),c=(0,r.createAsyncThunk)("flags/updateVisited",(async(e,t)=>{let{getState:s}=t;const{wallet:{address:r}}=s();if(!a.account.isAddress(r))throw new Error("Wallet is not connected yet");const i=new n.Z(r).createInstance("sentre");return await i.setItem("visited",e),{visited:e}})),d=(0,r.createAsyncThunk)("flags/updateLoading",(async e=>({loading:e}))),l=(0,r.createSlice)({name:i,initialState:{visited:!0,loading:!0},reducers:{},extraReducers:e=>{e.addCase(o.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(c.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(d.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)}))}}).reducer},87358:(e,t,s)=>{"use strict";s.d(t,{Qy:()=>p,ZP:()=>v,u5:()=>y});var r=s(55754),a=s(19289),n=s(70103),i=s(85912),o=s(87482),c=s(5105),d=s(58851),l=s(21028),u=s(65090),h=s(33015),g=s(92871),w=s(33361),f=s(51865);(0,r.createStoreHook)(n.RootContext);const y=(0,r.createDispatchHook)(n.RootContext),p=(0,r.createSelectorHook)(n.RootContext),m=(0,a.configureStore)({middleware:e=>e(i.h),devTools:(0,i.$)("sentre"),reducer:{ui:o.ZP,flags:c.ZP,page:d.ZP,wallet:l.ZP,accounts:u.ZP,mints:h.ZP,pools:g.ZP,search:w.ZP,walkthrough:f.ZP}}),v=179==s.j?m:null},33015:(e,t,s)=>{"use strict";s.d(t,{ZP:()=>d,ih:()=>i});var r=s(19289),a=s(95418);const n="mints",i=(0,r.createAsyncThunk)("mints/getMint",(async(e,t)=>{let{address:s,force:r=!1}=e,{getState:n}=t;if(!a.account.isAddress(s))throw new Error("Invalid mint address");if(!r){const{accounts:{[s]:e}}=n();if(e)return{[s]:e}}const{splt:i}=window.sentre;return{[s]:await i.getMintData(s)}})),o=(0,r.createAsyncThunk)("mints/upsetMint",(async e=>{let{address:t,data:s}=e;if(!a.account.isAddress(t))throw new Error("Invalid address");if(!s)throw new Error("Data is empty");return{[t]:s}})),c=(0,r.createAsyncThunk)("mints/deleteMint",(async e=>{let{address:t}=e;if(!a.account.isAddress(t))throw new Error("Invalid address");return{address:t}})),d=(0,r.createSlice)({name:n,initialState:{},reducers:{},extraReducers:e=>{e.addCase(i.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(o.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(c.fulfilled,((e,t)=>{let{payload:s}=t;delete e[s.address]}))}}).reducer},58851:(e,t,s)=>{"use strict";s.d(t,{T$:()=>f,Xg:()=>h,ZP:()=>m,eI:()=>y,ij:()=>w,mw:()=>g,qS:()=>p});var r=s(19289),a=s(95418),n=s(3007),i=s(60980);const{register:{senreg:o,extra:c}}=i.Z,d=(e,t)=>t&&Array.isArray(t)?t.filter((t=>e[t])):[],l="page",u={register:{},appIds:[]},h=(0,r.createAsyncThunk)("page/loadRegister",(async()=>({register:{...await(async()=>{try{const e=await fetch(o);return await e.json()}catch(e){return{}}})(),...c}}))),g=(0,r.createAsyncThunk)("page/installManifest",(async(e,t)=>{let{getState:s}=t;const{wallet:{address:r},page:{appIds:n,register:i}}=s();if(!a.account.isAddress(r))throw new Error("Wallet is not connected yet.");if(n.includes(e.appId))throw new Error("Cannot run sandbox for an installed application.");const o=[...n];o.push(e.appId);const c={...i};return c[e.appId]=e,{appIds:o,register:c}})),w=(0,r.createAsyncThunk)("page/loadPage",(async(e,t)=>{let{getState:s}=t;const{wallet:{address:r},page:{register:i}}=s();if(!a.account.isAddress(r))throw new Error("Wallet is not connected yet.");const o=new n.Z(r).createInstance("sentre");return{appIds:d(i,await o.getItem("appIds")||u.appIds)}})),f=(0,r.createAsyncThunk)("page/updatePage",(async(e,t)=>{let{getState:s}=t;const{wallet:{address:r},page:{register:i}}=s();if(!a.account.isAddress(r))throw new Error("Wallet is not connected yet.");e=d(i,e);const o=new n.Z(r).createInstance("sentre");return await o.setItem("appIds",e),{appIds:e}})),y=(0,r.createAsyncThunk)("page/installApp",(async(e,t)=>{let{getState:s}=t;const{wallet:{address:r},page:{appIds:i}}=s();if(!a.account.isAddress(r))throw new Error("Wallet is not connected yet.");if(i.includes(e))return{};const o=[...i];o.push(e);const c=new n.Z(r).createInstance("sentre");return await c.setItem("appIds",o),{appIds:o}})),p=(0,r.createAsyncThunk)("page/uninstallApp",(async(e,t)=>{let{getState:s}=t;const{wallet:{address:r},page:{appIds:i}}=s();if(!a.account.isAddress(r))throw new Error("Wallet is not connected yet.");if(!i.includes(e))return{};const o=i.filter((t=>t!==e)),c=new n.Z(r),d=c.createInstance("sentre");return await d.setItem("appIds",o),await c.dropInstance(e),{appIds:o}})),m=(0,r.createSlice)({name:l,initialState:u,reducers:{},extraReducers:e=>{e.addCase(h.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(g.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(w.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(f.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(y.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(p.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)}))}}).reducer},92871:(e,t,s)=>{"use strict";s.d(t,{E6:()=>l,ZP:()=>u,d2:()=>c});var r=s(19289),a=s(95418),n=s(60980);const{sol:{taxmanAddress:i}}=n.Z,o="pools",c=(0,r.createAsyncThunk)("pools/getPools",(async()=>{const{swap:e}=window.sentre,t=await e.connection.getProgramAccounts(e.swapProgramId,{filters:[{dataSize:257},{memcmp:{bytes:i,offset:65}}]});let s={};return t.forEach((t=>{let{pubkey:r,account:{data:a}}=t;const n=r.toBase58(),i=e.parsePoolData(a);s[n]=i})),s})),d=(0,r.createAsyncThunk)("pools/getPool",(async(e,t)=>{let{address:s}=e,{getState:r}=t;if(!a.account.isAddress(s))throw new Error("Invalid pool address");const{pools:{[s]:n}}=r();if(n)return{[s]:n};const{swap:i}=window.sentre;return{[s]:await i.getPoolData(s)}})),l=(0,r.createAsyncThunk)("pools/upsetPool",(async e=>{let{address:t,data:s}=e;if(!a.account.isAddress(t))throw new Error("Invalid pool address");if(!s)throw new Error("Data is empty");return{[t]:s}})),u=(0,r.createSlice)({name:o,initialState:{},reducers:{},extraReducers:e=>{e.addCase(c.fulfilled,((e,t)=>{let{payload:s}=t;return s})).addCase(d.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(l.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)}))}}).reducer},33361:(e,t,s)=>{"use strict";s.d(t,{K4:()=>o,ZP:()=>d,sO:()=>i,yx:()=>n});var r=s(19289);const a="search",n=(0,r.createAsyncThunk)("search/setVisible",(async e=>({visible:e}))),i=(0,r.createAsyncThunk)("search/setValue",(async e=>({value:e}))),o=(0,r.createAsyncThunk)("search/setLoading",(async e=>({loading:e}))),c=(0,r.createAsyncThunk)("search/setDisabled",(async e=>({disabled:e}))),d=(0,r.createSlice)({name:a,initialState:{visible:!1,value:"",loading:!1,disabled:!1},reducers:{},extraReducers:e=>{e.addCase(n.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(i.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(o.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(c.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)}))}}).reducer},87482:(e,t,s)=>{"use strict";s.d(t,{AY:()=>u,Dc:()=>o,SI:()=>c,TK:()=>l,ZP:()=>h,zi:()=>d});var r=s(19289);const a=()=>{const e=window.innerWidth;return e<576?"xs":e<768?"sm":e<992?"md":e<1200?"lg":e<1400?"xl":"xxl"},n="ui",i={theme:window.matchMedia("(prefers-color-scheme: light)").matches?"light":"dark",width:window.innerWidth,infix:a(),touchable:"ontouchstart"in window||navigator.maxTouchPoints>0,visibleActionCenter:!1,visibleInstaller:!1,background:{light:"",dark:""}},o=(0,r.createAsyncThunk)("ui/setTheme",(async e=>({theme:e}))),c=(0,r.createAsyncThunk)("ui/resize",(async()=>({width:window.innerWidth,infix:a()}))),d=(0,r.createAsyncThunk)("ui/setVisibleActionCenter",(async e=>({visibleActionCenter:e}))),l=(0,r.createAsyncThunk)("ui/setVisibleInstaller",(async e=>({visibleInstaller:e}))),u=(0,r.createAsyncThunk)("ui/setBackground",(async e=>({background:e}))),h=(0,r.createSlice)({name:n,initialState:i,reducers:{},extraReducers:e=>{e.addCase(o.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(c.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(d.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(l.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(u.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)}))}}).reducer},51865:(e,t,s)=>{"use strict";s.d(t,{Gm:()=>a,Rw:()=>o,ZP:()=>c});var r=s(19289);let a;!function(e){e[e.Default=0]="Default",e[e.NewComer=1]="NewComer"}(a||(a={}));const n="walkthrough",i={type:a.Default,run:!1,step:0},o=(0,r.createAsyncThunk)(`${n}/setWalkthrough`,(async e=>({...e}))),c=(0,r.createSlice)({name:n,initialState:i,reducers:{},extraReducers:e=>{e.addCase(o.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)}))}}).reducer},21028:(e,t,s)=>{"use strict";s.d(t,{Dx:()=>u,K8:()=>g,UP:()=>h,Wh:()=>l,ZP:()=>f,co:()=>w});var r=s(19289),a=s(95418),n=s(60980),i=s(20832);const o=async e=>{const{sol:{node:t,spltAddress:s,splataAddress:r,swapAddress:o}}=n.Z;window.sentre={wallet:e||new i.kI,lamports:new a.Lamports(t),splt:new a.SPLT(s,r,t),swap:new a.Swap(o,s,r,t)}},c="wallet",d={visible:!1,address:"",lamports:BigInt(0)},l=(0,r.createAsyncThunk)("wallet/openWallet",(async()=>({visible:!0}))),u=(0,r.createAsyncThunk)("wallet/closeWallet",(async()=>({visible:!1}))),h=(0,r.createAsyncThunk)("wallet/connectWallet",(async e=>{if(!e)throw new Error("Invalid wallet instance");await o(e);const t=await e.getAddress(),s=await window.sentre.lamports.getLamports(t);return{address:t,lamports:BigInt(s),visible:!1}})),g=(0,r.createAsyncThunk)("wallet/updateWallet",(async e=>{let{lamports:t}=e;return{lamports:t}})),w=(0,r.createAsyncThunk)("wallet/disconnectWallet",(async()=>{await(async()=>{var e;null!==(e=window.sentre)&&void 0!==e&&e.wallet&&window.sentre.wallet.disconnect(),await o()})(),window.location.reload()})),f=(0,r.createSlice)({name:c,initialState:d,reducers:{},extraReducers:e=>{e.addCase(l.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(u.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(h.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(g.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)})).addCase(w.fulfilled,((e,t)=>{let{payload:s}=t;Object.assign(e,s)}))}}).reducer},20832:(e,t,s)=>{"use strict";s.d(t,{fp:()=>C,IW:()=>g,kI:()=>n,X5:()=>u,j1:()=>f,j7:()=>d,nq:()=>S,Lc:()=>E,i_:()=>T,KE:()=>v});var r=s(88490);const a=class{constructor(e){this.walletType=void 0,this.getProvider=async()=>{throw new Error("Wallet is not connected")},this.getAddress=async()=>{throw new Error("Wallet is not connected")},this.signTransaction=async e=>{const{signature:t,publicKey:s}=await this.rawSignTransaction(e);return e.addSignature(s,t),e},this.rawSignTransaction=async e=>{throw new Error("Wallet is not connected")},this.signMessage=async e=>{throw new Error("Wallet is not connected")},this.verifySignature=async(e,t,s)=>{throw new Error("Wallet is not connected")},this.disconnect=async()=>{r.Z.clear("WalletType");(await this.getProvider()).disconnect()},this.walletType=e,r.Z.set("WalletType",this.walletType)}};const n=class extends a{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:()=>{};super("Guest"),this._callback=()=>{},this._error=()=>{throw new Error("You are in the Guest Mode. Please connect your personal wallet to proceed the action.")},this.getProvider=async()=>({address:"GuestAccount11111111111111111111111111111111",disconnect:()=>{}}),this.getAddress=async()=>{const{address:e}=await this.getProvider();return e},this.rawSignTransaction=async e=>(await this._callback(),this._error()),this.signMessage=async e=>(await this._callback(),this._error()),this.verifySignature=async(e,t,s)=>(await this._callback(),this._error()),this._callback=e}};var i=s(44967),o=s(95418),c=s(97429).Buffer;const d=class extends a{constructor(e){super("SecretKey"),this._setSecretKey=e=>{if(!e)throw new Error("Invalid secret key");r.Z.set("SecretKey",e)},this.getProvider=async()=>{const e=r.Z.get("SecretKey"),t=o.account.fromSecretKey(e);if(!t)throw new Error("Cannot get the keystore-based provider");return{keypair:t,disconnect:()=>r.Z.clear("SecretKey")}},this.getAddress=async()=>{const{keypair:e}=await this.getProvider();return e.publicKey.toBase58()},this.rawSignTransaction=async e=>{if(!window.confirm("Please confirm to sign the transaction!"))throw new Error("User rejects to sign the transaction");const{keypair:t}=await this.getProvider(),s=e.serializeMessage();return{publicKey:t.publicKey,signature:i.sign.detached(s,t.secretKey)}},this.signMessage=async e=>{if(!e)throw new Error("Message must be a non-empty string");if(!window.confirm(`Please confirm to sign the message! Message: ${e}`))throw new Error("User rejects to sign the message");const{keypair:t}=await this.getProvider(),s=c.from(t.secretKey).toString("hex");return{...o.account.signMessage(e,s)}},this.verifySignature=async(e,t,s)=>{s=s||await this.getAddress();return o.account.verifySignature(s,e,t)},this._setSecretKey(e)}};var l=s(97429).Buffer;const u=class extends a{constructor(e,t){super("SecretKey"),this._setSecretKey=(e,t)=>{const s=o.account.fromKeystore(e,t);if(!s)throw new Error("Invalid ketstore or password");const a=l.from(s.secretKey).toString("hex");r.Z.set("SecretKey",a)},this.getProvider=async()=>{const e=r.Z.get("SecretKey"),t=o.account.fromSecretKey(e);if(!t)throw new Error("Cannot get the keystore-based provider");return{keypair:t,disconnect:()=>r.Z.clear("SecretKey")}},this.getAddress=async()=>{const{keypair:e}=await this.getProvider();return e.publicKey.toBase58()},this.rawSignTransaction=async e=>{if(!window.confirm("Please confirm to sign the transaction!"))throw new Error("User rejects to sign the transaction");const{keypair:t}=await this.getProvider(),s=e.serializeMessage();return{publicKey:t.publicKey,signature:i.sign.detached(s,t.secretKey)}},this.signMessage=async e=>{if(!e)throw new Error("Message must be a non-empty string");if(!window.confirm(`Please confirm to sign the message! Message: ${e}`))throw new Error("User rejects to sign the message");const{keypair:t}=await this.getProvider(),s=l.from(t.secretKey).toString("hex");return{...o.account.signMessage(e,s)}},this.verifySignature=async(e,t,s)=>{s=s||await this.getAddress();return o.account.verifySignature(s,e,t)},this._setSecretKey(e,t)}};var h=s(68532);const g=class extends a{constructor(){super("Coin98"),this.getProvider=async()=>{var e;const{sol:t}=(null===(e=window)||void 0===e?void 0:e.coin98)||{};if(!t)throw new Error("Wallet is not connected");return t},this.getAddress=async()=>{const e=await this.getProvider(),[t]=await e.request({method:"sol_accounts"})||[];if(!o.account.isAddress(t))throw new Error("There is no Solana account");return t},this.rawSignTransaction=async e=>{const t=await this.getProvider(),s=await this.getAddress(),r=o.account.fromAddress(s);e.feePayer=r;const{signature:a}=await t.request({method:"sol_sign",params:[e]});return{publicKey:r,signature:(0,h.decode)(a)}},this.signMessage=async e=>{if(!e)throw new Error("Message must be a non-empty string");const t=await this.getProvider();return await t.request({method:"sol_sign",params:[e]})},this.verifySignature=async(e,t,s)=>{s=s||await this.getAddress();return await o.account.verifySignature(s,e,t)}}};var w=s(97429).Buffer;const f=class extends a{constructor(){super("Phantom"),this.getProvider=async()=>{const{solana:e}=window;if(null===e||void 0===e||!e.isPhantom)throw new Error("Wallet is not connected");return e.isConnected?e:(e.connect(),await new Promise((t=>e.on("connect",(()=>t(e))))))},this.getAddress=async()=>{const e=(await this.getProvider()).publicKey.toString();if(!o.account.isAddress(e))throw new Error("There is no Solana account");return e},this.rawSignTransaction=async e=>{const t=await this.getProvider(),s=await this.getAddress(),r=o.account.fromAddress(s);e.feePayer=r;const{signature:a}=await t.signTransaction(e);return{publicKey:r,signature:a}},this.signMessage=async e=>{if(!e)throw new Error("Message must be a non-empty string");const t=await this.getProvider(),s=await this.getAddress(),r=(new TextEncoder).encode(e),{signature:a}=await t.signMessage(r,"utf8");return{address:s,signature:w.from(a).toString("hex"),message:e}},this.verifySignature=async(e,t,s)=>{s=s||await this.getAddress();const r=o.account.fromAddress(s),a=w.from(e,"hex"),n=(new TextEncoder).encode(t);return i.sign.detached.verify(n,a,r.toBuffer())}}};var y=s(12053),p=s(60980),m=s(97429).Buffer;const v=class extends a{constructor(){super("SolletWeb"),this.provider=void 0,this.getProvider=async()=>(this.provider.connected||await this.provider.connect(),this.provider),this.getAddress=async()=>{const e=await this.getProvider();if(!e.publicKey)throw new Error("Cannot connect to Sollet Web");return e.publicKey.toBase58()},this.rawSignTransaction=async e=>{const t=await this.getProvider(),s=await this.getAddress(),r=o.account.fromAddress(s);e.feePayer=r;const{signature:a}=await t.signTransaction(e);return{publicKey:r,signature:a}},this.signMessage=async e=>{if(!e)throw new Error("Message must be a non-empty string");const t=await this.getProvider(),s=await this.getAddress(),r=(new TextEncoder).encode(e),{signature:a}=await t.sign(r,"utf8");return{address:s,signature:m.from(a).toString("hex"),message:e}},this.verifySignature=async(e,t,s)=>{s=s||await this.getAddress();const r=o.account.fromAddress(s),a=m.from(e,"hex"),n=(new TextEncoder).encode(t);return i.sign.detached.verify(n,a,r.toBuffer())};const{sol:{node:e}}=p.Z;this.provider=new y.Z("https://www.sollet.io",e)}};var A=s(71256),b=s(97429).Buffer;const S=class extends a{constructor(){super("Slope"),this.provider=void 0,this.getProvider=async()=>{const{Slope:e}=window||{};if(!e)throw new Error("Cannot connect to Slope");return this.provider||(this.provider=new e,await this.provider.connect()),this.provider},this.getAddress=async()=>{const e=await this.getProvider(),{data:t}=await e.connect();if(!t.publicKey)throw new Error("Wallet is not connected");return t.publicKey},this.rawSignTransaction=async e=>{const t=await this.getProvider(),s=(0,h.encode)(e.serializeMessage()),{msg:r,data:a}=await t.signTransaction(s);if(!a.publicKey)throw new Error(r);return{publicKey:new A.PublicKey(a.publicKey),signature:(0,h.decode)(a.signature)}},this.verifySignature=async(e,t,s)=>{const r=s||await this.getAddress(),a=o.account.fromAddress(r),n=b.from(e,"hex"),c=(new TextEncoder).encode(t);return i.sign.detached.verify(c,n,a.toBuffer())},this.provider=null}};var P=s(97429).Buffer;const T=class extends a{constructor(){super("SolflareWeb"),this.provider=void 0,this.getProvider=async()=>(this.provider.connected||await this.provider.connect(),this.provider),this.getAddress=async()=>{const e=await this.getProvider();if(!e.publicKey)throw new Error("Cannot connect to Solflare");return e.publicKey.toBase58()},this.rawSignTransaction=async e=>{const t=await this.getProvider(),s=await this.getAddress(),r=o.account.fromAddress(s);e.feePayer=r;const{signature:a}=await t.signTransaction(e);return{publicKey:r,signature:a}},this.signMessage=async e=>{if(!e)throw new Error("Message must be a non-empty string");const t=await this.getProvider(),s=await this.getAddress(),r=(new TextEncoder).encode(e),{signature:a}=await t.sign(r,"utf8");return{address:s,signature:P.from(a).toString("hex"),message:e}},this.verifySignature=async(e,t,s)=>{s=s||await this.getAddress();const r=o.account.fromAddress(s),a=P.from(e,"hex"),n=(new TextEncoder).encode(t);return i.sign.detached.verify(n,a,r.toBuffer())};const{sol:{node:e}}=p.Z;this.provider=new y.Z("https://solflare.com/provider",e)}};var k=s(97429).Buffer;const E=class extends a{constructor(){super("SolflareExtension"),this.getProvider=async()=>{const{solflare:e}=window;if(!e.isSolflare)throw new Error("Wallet is not connected");return e.isConnected?e:(e.connect(),await new Promise((t=>e.on("connect",(()=>t(e))))))},this.getAddress=async()=>{const e=(await this.getProvider()).publicKey.toString();if(!o.account.isAddress(e))throw new Error("There is no Solana account");return e},this.rawSignTransaction=async e=>{const t=await this.getProvider(),s=await this.getAddress(),r=o.account.fromAddress(s);e.feePayer=r;const{signature:a}=await t.signTransaction(e);return{publicKey:r,signature:a}},this.signMessage=async e=>{if(!e)throw new Error("Message must be a non-empty string");const t=await this.getProvider(),s=await this.getAddress(),r=(new TextEncoder).encode(e),{signature:a}=await t.signMessage(r,"utf8");return{address:s,signature:k.from(a).toString("hex"),message:e}},this.verifySignature=async(e,t,s)=>{s=s||await this.getAddress();const r=o.account.fromAddress(s),a=k.from(e,"hex"),n=(new TextEncoder).encode(t);return i.sign.detached.verify(n,a,r.toBuffer())}}};var I=s(97429).Buffer;const C=class extends a{constructor(){super("Clover"),this.getProvider=async()=>{const{clover_solana:e}=window;if(null===e||void 0===e||!e.isCloverWallet)throw new Error("Wallet is not connected");return e},this.getAddress=async()=>{const e=await this.getProvider(),t=await e.getAccount();if(!o.account.isAddress(t))throw new Error("There is no Solana account");return t},this.rawSignTransaction=async e=>{const t=await this.getProvider(),s=await this.getAddress(),r=o.account.fromAddress(s);e.feePayer=r;const{signature:a}=await t.signTransaction(e);return{publicKey:r,signature:a}},this.signMessage=async e=>{if(!e)throw new Error("Message must be a non-empty string");const t=await this.getProvider(),s=await this.getAddress(),r=(new TextEncoder).encode(e),{signature:a}=await t.signMessage(r,"utf8");return{address:s,signature:I.from(a).toString("hex"),message:e}},this.verifySignature=async(e,t,s)=>{s=s||await this.getAddress();const r=o.account.fromAddress(s),a=I.from(e,"hex"),n=(new TextEncoder).encode(t);return i.sign.detached.verify(n,a,r.toBuffer())}}}},57452:(e,t,s)=>{"use strict";s.d(t,{R:()=>o});const r={ttl:3e4},a={limit:{calls:10,time:1e3},cache:r};class n{constructor(e){this.key="",this.resolveQueue=[],this.rejectQueue=[],this.key=e}add(e,t){this.resolveQueue.push(e),this.rejectQueue.push(t)}resolves(e){for(;this.resolveQueue.length>0;){this.resolveQueue.shift()(e)}}rejects(e){for(;this.rejectQueue.length>0;){this.rejectQueue.shift()(e)}}}class i{static set(e,t){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:r;this.mapCache.set(e,t),setTimeout((()=>{this.mapCache.delete(e)}),s.ttl)}static get(e){return this.mapCache.get(e)}}i.mapCache=new Map;class o{static getSingleFlight(e){const t=JSON.stringify(e);if(this.mapInstance.has(t)){const e=this.mapInstance.get(t);if(e)return e}let s=new c(e);return this.mapInstance.set(t,s),s}static async load(e,t){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};"object"===typeof e&&(e=JSON.stringify(e));let r=o.getSingleFlight(s);o.mapInstance.set(e,r);const a=new n(e);return r.load(a,t)}}o.mapInstance=new Map;class c{constructor(e){this.config=void 0,this.intervalRequest=void 0,this.timeLogs=[],this.mapRequestCalling=new Map,this.requestQueue=[],this.config=Object.assign(a,e)}async load(e,t){const s=i.get(e.key);if(s)return Promise.resolve(s);let r=!1,a=this.mapRequestCalling.get(e.key);return a||(a=e,r=!0,this.mapRequestCalling.set(a.key,a)),new Promise(((e,s)=>{if(!a)return s("Not found request!");a.add(e,s),r&&this.fetch(a,t)}))}fetch(e,t){if(!this.validateLimit())return this.addRequestQueue(e,t);this.createTimeLogs(),t().then((t=>{i.set(e.key,t,this.config.cache),e.resolves(t)})).catch((t=>{e.rejects(t)})).finally((()=>{this.mapRequestCalling.delete(e.key),this.fetchRequestQueue(t)}))}fetchRequestQueue(e){if(!this.validateLimit())return;const t=this.requestQueue.shift();t&&this.load(t,e),0===this.requestQueue.length&&this.intervalRequest&&clearInterval(this.intervalRequest)}addRequestQueue(e,t){var s;this.requestQueue.push(e),this.intervalRequest=setInterval((()=>{this.fetchRequestQueue(t)}),null===(s=this.config.limit)||void 0===s?void 0:s.time)}validateLimit(){return!0}createTimeLogs(){var e;if(!this.config.limit)return;const t=(new Date).getTime();this.timeLogs.push(t),this.timeLogs.length>(null===(e=this.config.limit)||void 0===e?void 0:e.calls)&&this.timeLogs.shift()}}},85912:(e,t,s)=>{"use strict";s.d(t,{$:()=>o,h:()=>c});var r=s(71256),a=s(48744),n=s.n(a),i=s(97429).Buffer;const o=e=>!1;BigInt.prototype.toJSON=function(){return this.toString()};const c={serializableCheck:{isSerializable:e=>"undefined"===typeof e||null===e||"string"===typeof e||"boolean"===typeof e||"number"===typeof e||Array.isArray(e)||(e=>{if(null===e)return!1;const t=Object.getPrototypeOf(e);return null!==t&&null===Object.getPrototypeOf(t)})(e)||"bigint"===typeof e||e instanceof r.PublicKey||e instanceof n()||e instanceof i}}},83868:(e,t,s)=>{"use strict";s.d(t,{Z:()=>o});var r=s(43912),a=s(34559),n=s(97429).Buffer;class i{constructor(){this._ipfs=async()=>{try{return window.ipfs||(window.ipfs=await(0,r.Ue)()),window.ipfs}catch(e){return await(0,a.sA)(500),await this._ipfs()}},this.get=async e=>{if(!i.isCID(e))throw new Error("Invalid CID");const t=await this._ipfs(),s=await t.cat(e);let r="";for await(const a of s)r+=n.from(a).toString();return JSON.parse(r)},this.set=async e=>{if(!e)throw new Error("Empty data");const t=JSON.stringify(e),s=await this._ipfs(),{path:r}=await s.add(t);return r}}}i.isCID=e=>{try{return!!e&&r.bf.multihash(e)}catch(t){return!1}};const o=i},15190:(e,t,s)=>{"use strict";s.d(t,{Bv:()=>u,OB:()=>c,ef:()=>d,Eu:()=>l});const r="sentre",a=window.localStorage,n=e=>{try{return e?JSON.parse(e):null}catch(t){return null}},i={set:(e,t)=>{let s=n(a.getItem(r));s&&"object"===typeof s||(s={}),s[e]=t,a.setItem(r,JSON.stringify(s))},get:e=>{let t=n(a.getItem(r));return t&&"object"===typeof t?t[e]:null},clear:e=>{i.set(e,null)}},o=i,c="production",d=(()=>{switch(o.get("network")){case"devnet":return"devnet";case"testnet":return"testnet";default:return"mainnet"}})(),l=e=>(o.set("network",e),window.location.reload()),u=(()=>{switch(d){case"devnet":return 103;case"testnet":return 102;default:return 101}})()},88490:(e,t,s)=>{"use strict";s.d(t,{Z:()=>o});const r="sentre",a=window.sessionStorage,n=e=>{try{return e?JSON.parse(e):null}catch(t){return!1}},i={set:(e,t)=>{let s=n(a.getItem(r));s&&"object"===typeof s||(s={}),s[e]=t,a.setItem(r,JSON.stringify(s))},get:e=>{let t=n(a.getItem(r));return t&&"object"===typeof t?t[e]:null},clear:e=>{i.set(e,null)}},o=i},43094:()=>{},69159:()=>{},35883:()=>{},46601:()=>{},89214:()=>{},5696:()=>{},85568:()=>{},64009:()=>{},42611:()=>{},88795:()=>{},89408:()=>{},87017:()=>{},74056:()=>{},57600:()=>{},21724:()=>{},39370:()=>{},62678:()=>{},25819:()=>{},52361:()=>{},94616:()=>{},55024:()=>{}}]);
//# sourceMappingURL=898.b9463bea.chunk.js.map